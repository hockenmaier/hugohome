<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kitchen Calendar List</title>
    <style>
      body {
        margin: 0;
        padding: 12px;
        background: #000;
        color: #fff;
        font-family: Arial, Helvetica, sans-serif;
        max-width: 800px;
        height: 480px;
        overflow: hidden;
      }
      body.vandenberg-pulse {
        animation: vandenbergPulse 10s ease-in-out infinite;
      }
      @keyframes vandenbergPulse {
        0% {
          background: #000;
        }
        50% {
          background: #9e4f24;
        }
        100% {
          background: #000;
        }
      }
      .top-row {
        overflow: hidden;
        padding-bottom: 0px;
        border-bottom: 1px solid #333;
      }
      .date-box {
        float: left;
        width: 45%;
        text-align: left;
      }
      .time-box {
        float: right;
        width: 50%;
        text-align: right;
        padding-right: 15px;
      }
      .date-text {
        font-size: 46px;
        margin: 0;
        line-height: 1.1;
        color: #e0e0e0;
      }
      .time-text {
        margin: 0;
        line-height: 1;
        font-size: 110px;
        font-weight: bold;
        color: #ffffff;
      }
      .time-text .seconds {
        font-size: 32px;
        color: #888;
      }
      .time-text .period {
        font-size: 36px;
        color: #ffffff;
      }
      .section-title {
        margin: 12px 0 6px;
        font-size: 20px;
        color: #9fbfa0;
        letter-spacing: 0.5px;
      }
      #today-section .section-title {
        color: #24f270;
      }
      .content-row {
        overflow: hidden;
        padding-top: 10px;
      }
      .left-column {
        float: left;
        width: 70%;
      }
      .right-column {
        float: right;
        width: 30%;
        text-align: right;
      }
      .list-item {
        margin: 6px 0;
        font-size: 18px;
        line-height: 1.3;
        color: #f5f5f5;
      }
      .date-part {
        font-weight: bold;
      }
      .status-sunny,
      .status-clear {
        color: #f2d36b;
      }
      .status-rain,
      .status-drizzle {
        color: #8fc7ff;
      }
      .status-cloudy,
      .status-overcast,
      .status-foggy {
        color: #b0b0b0;
      }
      .status-thunderstorm {
        color: #c2a2ff;
      }
      .note {
        margin-top: 12px;
        font-size: 60%;
        color: #b0b0b0;
      }
      .nav-buttons {
        margin: 2px 0;
        display: inline-flex;
        gap: 10px;
      }
      .nav-button {
        background: #111;
        color: #fff;
        border: 1px solid #444;
        padding: 8px 14px;
        border-radius: 6px;
        font-size: 16px;
        line-height: 1.3;
        min-height: calc(1.3em * 1.3);
        cursor: pointer;
      }
      .nav-button:active {
        background: #1a1a1a;
      }
    </style>
  </head>
  <body>
    <div class="top-row">
      <div class="date-box">
        <p class="date-text" id="date-text"></p>
      </div>
      <div class="time-box">
        <p class="time-text" id="time-text"></p>
      </div>
    </div>

    <div class="content-row">
      <div class="left-column">
        <div id="today-section" style="display: none">
          <div class="section-title">Today</div>
          <div id="today-list"></div>
        </div>
        <div>
          <div class="section-title">Upcoming</div>
          <div id="upcoming-list"></div>
        </div>
        <div class="nav-buttons">
          <button id="return-button" class="nav-button">Return</button>
          <button id="next-button" class="nav-button">Next</button>
        </div>
        <div class="note">
          Data refreshes every hour. All times local. Sources: Nager, SpaceX,
          Open Meteo, curated astronomy.
        </div>
      </div>
      <div class="right-column">
        <div class="section-title">Weather</div>
        <div id="weather-now" class="list-item"></div>
        <div id="weather-today" class="list-item"></div>
        <div id="weather-outlook"></div>
      </div>
    </div>

    <script>
      const $time = document.getElementById("time-text");
      const $date = document.getElementById("date-text");
      const $upcoming = document.getElementById("upcoming-list");
      const $todaySection = document.getElementById("today-section");
      const $todayList = document.getElementById("today-list");
      const $weatherNow = document.getElementById("weather-now");
      const $weatherToday = document.getElementById("weather-today");
      const $weatherOutlook = document.getElementById("weather-outlook");
      const $nextButton = document.getElementById("next-button");
      const $returnButton = document.getElementById("return-button");

      let eventsCache = [];
      let upcomingPage = 0;
      let autoReturnTimer = null;
      const DEFAULT_UPCOMING_SIZE = 6;
      const TODAY_UPCOMING_SIZE = 4;
      let hasTodayEvents = false;

      if (!Array.prototype.flat) {
        Object.defineProperty(Array.prototype, "flat", {
          value: function (depth = 1) {
            const result = [];
            const flatten = (arr, d) => {
              for (const item of arr) {
                if (Array.isArray(item) && d > 0) {
                  flatten(item, d - 1);
                } else {
                  result.push(item);
                }
              }
            };
            flatten(this, depth);
            return result;
          },
          writable: true,
          configurable: true,
        });
      }

      if (!Array.prototype.flatMap) {
        Object.defineProperty(Array.prototype, "flatMap", {
          value: function (callback, thisArg) {
            return this.map(callback, thisArg).flat();
          },
          writable: true,
          configurable: true,
        });
      }

      function pad(n) {
        return n.toString().padStart(2, "0");
      }

      function ordinal(n) {
        const s = ["th", "st", "nd", "rd"];
        const v = n % 100;
        return n + (s[(v - 20) % 10] || s[v] || s[0]);
      }

      const nowOverride = (() => {
        const params = new URLSearchParams(window.location.search);
        const value = params.get("now");
        if (!value) return null;
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      })();

      function currentTime() {
        return nowOverride ? new Date(nowOverride) : new Date();
      }

      function renderClock() {
        const now = currentTime();
        const hoursRaw = now.getHours();
        const hours = hoursRaw % 12 === 0 ? 12 : hoursRaw % 12;
        const minutes = pad(now.getMinutes());
        const seconds = pad(now.getSeconds());
        const period = hoursRaw >= 12 ? "PM" : "AM";
        $time.innerHTML = `${hours}:${minutes}<span class="seconds">${seconds}</span><span class="period">${period}</span>`;

        const dateString = now.toLocaleDateString(undefined, {
          weekday: "long",
        });
        const month = now.toLocaleDateString(undefined, { month: "short" });
        const day = ordinal(now.getDate());
        const year = now.getFullYear();
        $date.innerHTML = `${dateString}<br>${month} ${day}, ${year}`;
      }

      function formatTime(date) {
        return date.toLocaleTimeString(undefined, {
          hour: "numeric",
          minute: "2-digit",
          timeZone: "America/Los_Angeles",
        });
      }

      function renderList(container, events, options = {}) {
        const mode = options.mode || "upcoming";
        container.innerHTML = "";
        if (events.length === 0) {
          const empty = document.createElement("div");
          empty.className = "list-item";
          empty.textContent = "All quiet for now.";
          container.appendChild(empty);
          return;
        }
        events.forEach((ev) => {
          const line = document.createElement("div");
          line.className = "list-item";
          const datePart = ev.date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            timeZone: "America/Los_Angeles",
          });
          const timePart = ev.time ? ` at ${ev.time}` : "";
          if (mode === "today") {
            line.textContent = ev.time ? `${ev.title} at ${ev.time}` : ev.title;
          } else {
            const dateSpan = document.createElement("span");
            dateSpan.className = "date-part";
            dateSpan.textContent = `${datePart}${timePart}`;
            const titleSpan = document.createElement("span");
            titleSpan.textContent = `${ev.title} on `;
            line.appendChild(titleSpan);
            line.appendChild(dateSpan);
          }
          container.appendChild(line);
        });
      }

      function currentUpcomingSize() {
        return hasTodayEvents ? TODAY_UPCOMING_SIZE : DEFAULT_UPCOMING_SIZE;
      }

      function dedupeEvents(events) {
        const seen = new Set();
        return events.filter((ev) => {
          const datePart = ev.date.toISOString().slice(0, 10);
          const key = [
            (ev.title || "").toLowerCase(),
            ev.kind || "",
            datePart,
            ev.time || "",
          ].join("|");
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      }

      function clearAutoReturn() {
        if (autoReturnTimer) {
          clearTimeout(autoReturnTimer);
          autoReturnTimer = null;
        }
      }

      function autoReturnToDefault() {
        upcomingPage = 0;
        renderUpcoming();
        clearAutoReturn();
      }

      function scheduleAutoReturn() {
        clearAutoReturn();
        autoReturnTimer = setTimeout(autoReturnToDefault, 60 * 1000);
      }

      function setUpcomingPage(page) {
        upcomingPage = Math.max(0, page);
        renderUpcoming();
        if (upcomingPage === 0) {
          clearAutoReturn();
        } else {
          scheduleAutoReturn();
        }
      }

      function renderUpcoming() {
        const now = currentTime();
        const todayStart = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate()
        );
        const tomorrowStart = new Date(todayStart);
        tomorrowStart.setDate(tomorrowStart.getDate() + 1);
        const fourWeeks = new Date(now);
        fourWeeks.setDate(fourWeeks.getDate() + 28);

        const pageSize = currentUpcomingSize();

        const futureEvents = eventsCache
          .filter((e) => e.date >= tomorrowStart)
          .sort((a, b) => a.date - b.date);

        const defaultList = futureEvents
          .filter((e) => e.date <= fourWeeks)
          .slice(0, pageSize);

        const startIndex =
          upcomingPage === 0
            ? 0
            : defaultList.length + (upcomingPage - 1) * pageSize;
        const list =
          upcomingPage === 0
            ? defaultList
            : futureEvents.slice(startIndex, startIndex + pageSize);

        renderList($upcoming, list, { mode: "upcoming" });
      }

      function renderToday() {
        const now = currentTime();
        const todayStart = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate()
        );
        const tomorrowStart = new Date(todayStart);
        tomorrowStart.setDate(tomorrowStart.getDate() + 1);
        const todaysEvents = eventsCache
          .filter((e) => e.date >= todayStart && e.date < tomorrowStart)
          .sort((a, b) => a.date - b.date);
        hasTodayEvents = todaysEvents.length > 0;
        if (hasTodayEvents) {
          $todaySection.style.display = "block";
          renderList($todayList, todaysEvents, { mode: "today" });
        } else {
          $todaySection.style.display = "none";
          $todayList.innerHTML = "";
        }
      }

      async function fetchHolidays(year) {
        try {
          const res = await fetch(
            `https://date.nager.at/api/v3/PublicHolidays/${year}/US`
          );
          if (!res.ok) throw new Error("holiday fetch failed");
          const data = await res.json();
          return data.map((item) => ({
            date: new Date(item.date + "T12:00:00"),
            title: item.localName,
            kind: "holiday",
          }));
        } catch (err) {
          console.warn("Holiday fetch error", err);
          return [];
        }
      }

      function nthWeekdayOfMonth(year, monthIndex, weekday, nth) {
        const d = new Date(year, monthIndex, 1);
        let count = 0;
        while (d.getMonth() === monthIndex) {
          if (d.getDay() === weekday) {
            count++;
            if (count === nth) break;
          }
          d.setDate(d.getDate() + 1);
        }
        d.setHours(12, 0, 0, 0);
        return d;
      }

      function calculateTimeChanges(year) {
        const dstStart = nthWeekdayOfMonth(year, 2, 0, 2);
        const dstEnd = nthWeekdayOfMonth(year, 10, 0, 1);
        return [
          {
            date: dstStart,
            title: "Clocks jump forward",
            kind: "timechange",
            time: "2:00 AM",
          },
          {
            date: dstEnd,
            title: "Clocks fall back",
            kind: "timechange",
            time: "2:00 AM",
          },
        ];
      }

      function seasonEvents(year) {
        return [
          {
            date: new Date(year, 2, 20),
            title: "Spring Equinox",
            kind: "season",
          },
          {
            date: new Date(year, 5, 20),
            title: "Summer Solstice",
            kind: "season",
          },
          {
            date: new Date(year, 8, 22),
            title: "Autumn Equinox",
            kind: "season",
          },
          {
            date: new Date(year, 11, 21),
            title: "Winter Solstice",
            kind: "season",
          },
        ];
      }

      function meteorShowerEvents(year) {
        const template = [
          { month: 0, day: 3, title: "Quadrantids peak" },
          { month: 3, day: 22, title: "Lyrids peak" },
          { month: 4, day: 6, title: "Eta Aquariids peak" },
          { month: 6, day: 30, title: "Delta Aquariids peak" },
          { month: 7, day: 12, title: "Perseids peak" },
          { month: 9, day: 21, title: "Orionids peak" },
          { month: 10, day: 17, title: "Leonids peak" },
          { month: 11, day: 14, title: "Geminids peak" },
          { month: 11, day: 22, title: "Ursids peak" },
        ];
        return template.map((item) => ({
          date: new Date(year, item.month, item.day, 12, 0),
          title: item.title,
          kind: "astronomy",
        }));
      }

      function eclipseEvents(year) {
        const curated = [
          { date: "2024-03-25", title: "Penumbral Lunar Eclipse" },
          { date: "2024-04-08", title: "Total Solar Eclipse" },
          { date: "2024-09-18", title: "Partial Lunar Eclipse" },
          { date: "2024-10-02", title: "Annular Solar Eclipse" },
          { date: "2025-03-14", title: "Partial Solar Eclipse" },
          { date: "2025-03-29", title: "Total Lunar Eclipse" },
          { date: "2025-09-07", title: "Partial Lunar Eclipse" },
          { date: "2025-09-21", title: "Partial Solar Eclipse" },
          { date: "2026-02-17", title: "Annular Solar Eclipse" },
          { date: "2026-03-03", title: "Total Lunar Eclipse" },
          { date: "2026-08-28", title: "Partial Lunar Eclipse" },
          { date: "2026-08-12", title: "Total Solar Eclipse" },
          { date: "2027-02-06", title: "Annular Solar Eclipse" },
          { date: "2027-02-20", title: "Total Lunar Eclipse" },
          { date: "2027-07-18", title: "Partial Lunar Eclipse" },
          { date: "2027-08-02", title: "Total Solar Eclipse" },
          { date: "2028-01-26", title: "Annular Solar Eclipse" },
          { date: "2028-01-12", title: "Penumbral Lunar Eclipse" },
          { date: "2028-07-06", title: "Penumbral Lunar Eclipse" },
          { date: "2028-07-22", title: "Total Solar Eclipse" },
          { date: "2029-01-14", title: "Partial Solar Eclipse" },
          { date: "2029-06-12", title: "Partial Solar Eclipse" },
          { date: "2029-06-26", title: "Total Lunar Eclipse" },
          { date: "2029-12-20", title: "Penumbral Lunar Eclipse" },
          { date: "2030-05-22", title: "Annular Solar Eclipse" },
          { date: "2030-06-15", title: "Penumbral Lunar Eclipse" },
          { date: "2030-11-25", title: "Total Solar Eclipse" },
          { date: "2030-11-09", title: "Partial Lunar Eclipse" },
          { date: "2031-04-08", title: "Annular Solar Eclipse" },
          { date: "2031-09-30", title: "Hybrid Solar Eclipse" },
          { date: "2031-04-25", title: "Total Lunar Eclipse" },
          { date: "2031-10-18", title: "Partial Lunar Eclipse" },
          { date: "2032-03-20", title: "Total Solar Eclipse" },
          { date: "2032-09-12", title: "Annular Solar Eclipse" },
          { date: "2032-03-09", title: "Penumbral Lunar Eclipse" },
          { date: "2032-09-02", title: "Total Lunar Eclipse" },
          { date: "2033-03-30", title: "Hybrid Solar Eclipse" },
          { date: "2033-09-23", title: "Annular Solar Eclipse" },
          { date: "2033-04-14", title: "Penumbral Lunar Eclipse" },
          { date: "2033-10-08", title: "Total Lunar Eclipse" },
          { date: "2034-03-20", title: "Total Solar Eclipse" },
          { date: "2034-09-12", title: "Total Solar Eclipse" },
          { date: "2034-03-03", title: "Penumbral Lunar Eclipse" },
          { date: "2034-08-27", title: "Partial Lunar Eclipse" },
          { date: "2035-02-05", title: "Total Solar Eclipse" },
          { date: "2035-08-30", title: "Annular Solar Eclipse" },
          { date: "2035-01-24", title: "Penumbral Lunar Eclipse" },
          { date: "2035-07-30", title: "Partial Lunar Eclipse" },
          { date: "2036-02-15", title: "Annular Solar Eclipse" },
          { date: "2036-08-13", title: "Annular Solar Eclipse" },
          { date: "2036-01-10", title: "Total Lunar Eclipse" },
          { date: "2036-07-06", title: "Penumbral Lunar Eclipse" },
          { date: "2037-06-16", title: "Partial Solar Eclipse" },
          { date: "2037-01-26", title: "Total Solar Eclipse" },
          { date: "2037-07-22", title: "Penumbral Lunar Eclipse" },
          { date: "2037-12-10", title: "Total Lunar Eclipse" },
          { date: "2038-07-02", title: "Total Solar Eclipse" },
          { date: "2038-12-26", title: "Annular Solar Eclipse" },
          { date: "2038-06-22", title: "Partial Lunar Eclipse" },
          { date: "2038-12-16", title: "Penumbral Lunar Eclipse" },
          { date: "2039-06-21", title: "Annular Solar Eclipse" },
          { date: "2039-12-15", title: "Total Solar Eclipse" },
          { date: "2039-06-05", title: "Partial Lunar Eclipse" },
          { date: "2039-11-30", title: "Total Lunar Eclipse" },
          { date: "2040-05-10", title: "Annular Solar Eclipse" },
          { date: "2040-11-03", title: "Hybrid Solar Eclipse" },
          { date: "2040-05-06", title: "Total Lunar Eclipse" },
          { date: "2040-10-30", title: "Partial Lunar Eclipse" },
          { date: "2041-04-30", title: "Annular Solar Eclipse" },
          { date: "2041-10-25", title: "Annular Solar Eclipse" },
          { date: "2041-04-16", title: "Total Lunar Eclipse" },
          { date: "2041-10-10", title: "Penumbral Lunar Eclipse" },
          { date: "2042-04-19", title: "Hybrid Solar Eclipse" },
          { date: "2042-10-14", title: "Total Solar Eclipse" },
          { date: "2042-04-06", title: "Partial Lunar Eclipse" },
          { date: "2042-09-29", title: "Total Lunar Eclipse" },
          { date: "2043-04-09", title: "Annular Solar Eclipse" },
          { date: "2043-10-03", title: "Annular Solar Eclipse" },
          { date: "2043-03-27", title: "Penumbral Lunar Eclipse" },
          { date: "2043-09-21", title: "Partial Lunar Eclipse" },
          { date: "2044-03-21", title: "Hybrid Solar Eclipse" },
          { date: "2044-08-23", title: "Total Solar Eclipse" },
          { date: "2044-03-13", title: "Total Lunar Eclipse" },
          { date: "2044-09-06", title: "Partial Lunar Eclipse" },
        ];
        return curated
          .filter((ev) => new Date(ev.date).getFullYear() === year)
          .map((ev) => ({
            date: new Date(`${ev.date}T12:00:00`),
            title: ev.title,
            kind: "astronomy",
          }));
      }

      const SPACEX_QUERY_URL = "https://api.spacexdata.com/v5/launches/query";
      const SPACEX_UPCOMING_URL =
        "https://api.spacexdata.com/v4/launches/upcoming";
      const SPACEX_UPCOMING_V5_URL =
        "https://api.spacexdata.com/v5/launches/upcoming";
      const SPACEX_LAUNCHPADS_URL = "https://api.spacexdata.com/v4/launchpads";
      const LL2_SPACEX_UPCOMING_URL =
        "https://ll.thespacedevs.com/2.2.0/launch/upcoming/?limit=25&ordering=net&search=SpaceX&mode=detailed";

      function isVandenbergSite(value) {
        return typeof value === "string" && /vandenberg/i.test(value);
      }

      function normalizeLaunch(raw, launchpads) {
        const dateCandidate =
          raw.date_utc ||
          raw.date_local ||
          (raw.date_unix
            ? new Date(raw.date_unix * 1000).toISOString()
            : null) ||
          raw.date ||
          null;
        const parsedDate = dateCandidate ? new Date(dateCandidate) : null;
        if (!parsedDate || Number.isNaN(parsedDate.getTime())) return null;
        const launchpadId =
          typeof raw.launchpad === "string" ? raw.launchpad : null;
        const padInfo =
          launchpadId && launchpads[launchpadId]
            ? launchpads[launchpadId]
            : null;
        const site =
          (padInfo &&
            [padInfo.name, padInfo.locality || padInfo.region]
              .filter(Boolean)
              .join(" — ")) ||
          raw.site ||
          (raw.launchpad && (raw.launchpad.full_name || raw.launchpad.name)) ||
          launchpadId ||
          null;
        const baseTitle = raw.name || raw.title || "SpaceX launch";
        const isVandenberg =
          isVandenbergSite(site) ||
          isVandenbergSite(
            padInfo
              ? `${padInfo.name} ${padInfo.locality || padInfo.region || ""}`
              : null
          ) ||
          isVandenbergSite(
            raw.launchpad && raw.launchpad.locality
              ? raw.launchpad.locality
              : null
          );
        return {
          date: parsedDate,
          title: baseTitle,
          kind: "launch",
          time: formatTime(parsedDate),
          site,
          isVandenberg,
        };
      }

      function normalizeLl2Launch(raw) {
        const dateCandidate =
          raw.net || raw.window_start || raw.window_end || null;
        const parsedDate = dateCandidate ? new Date(dateCandidate) : null;
        if (!parsedDate || Number.isNaN(parsedDate.getTime())) return null;
        const pad = raw.pad || {};
        const location = pad.location || {};
        const site =
          pad.name ||
          pad.wiki_url ||
          location.name ||
          [location.name, location.country_code].filter(Boolean).join(", ") ||
          null;
        const baseTitle = raw.name || "SpaceX launch";
        const isVandenberg =
          isVandenbergSite(site) || isVandenbergSite(location.name);
        return {
          date: parsedDate,
          title: baseTitle,
          kind: "launch",
          time: formatTime(parsedDate),
          site,
          isVandenberg,
        };
      }

      async function fetchLaunchpads() {
        try {
          const res = await fetch(SPACEX_LAUNCHPADS_URL);
          if (!res.ok) throw new Error("launchpad fetch failed");
          const data = await res.json();
          return (Array.isArray(data) ? data : []).reduce((map, pad) => {
            if (pad.id) map[pad.id] = pad;
            return map;
          }, {});
        } catch (err) {
          console.warn("Launchpad fetch error", err);
          return {};
        }
      }

      async function fetchSpaceXViaQuery(now) {
        const res = await fetch(SPACEX_QUERY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: { upcoming: true, date_utc: { $gte: now.toISOString() } },
            options: { sort: { date_utc: "asc" }, limit: 50 },
          }),
        });
        if (!res.ok) throw new Error(`SpaceX query failed: ${res.status}`);
        const data = await res.json();
        return data && Array.isArray(data.docs) ? data.docs : [];
      }

      async function fetchSpaceXViaV4() {
        const res = await fetch(SPACEX_UPCOMING_URL);
        if (!res.ok) throw new Error(`SpaceX v4 failed: ${res.status}`);
        const data = await res.json();
        return Array.isArray(data) ? data : [];
      }

      async function fetchSpaceXViaV5() {
        const res = await fetch(SPACEX_UPCOMING_V5_URL);
        if (!res.ok) throw new Error(`SpaceX v5 failed: ${res.status}`);
        const data = await res.json();
        return Array.isArray(data) ? data : [];
      }

      async function fetchSpaceXViaLl2() {
        const res = await fetch(LL2_SPACEX_UPCOMING_URL);
        if (!res.ok) throw new Error(`SpaceDevs failed: ${res.status}`);
        const data = await res.json();
        const results = Array.isArray(data.results) ? data.results : [];
        return results;
      }

      async function fetchSpaceXLaunches() {
        const now = currentTime();
        let launches = [];
        let launchpads = {};
        let source = "spacex-v5";

        try {
          const [launchData, launchpadMap] = await Promise.all([
            fetchSpaceXViaV5(),
            fetchLaunchpads(),
          ]);
          launches = launchData;
          launchpads = launchpadMap;
        } catch (err) {
          console.warn("SpaceX v5 path failed", err);
          try {
            const [launchData, launchpadMap] = await Promise.all([
              fetchSpaceXViaV4(),
              fetchLaunchpads(),
            ]);
            launches = launchData;
            launchpads = launchpadMap;
            source = "spacex-v4";
          } catch (err2) {
            console.warn("SpaceX v4 path failed", err2);
            try {
              const [launchData, launchpadMap] = await Promise.all([
                fetchSpaceXViaQuery(now),
                fetchLaunchpads(),
              ]);
              launches = launchData;
              launchpads = launchpadMap;
              source = "spacex-query";
            } catch (err3) {
              console.warn("SpaceX query path failed", err3);
              launches = [];
            }
          }
        }

        const normalized = launches
          .map((entry) => normalizeLaunch(entry, launchpads))
          .filter(Boolean);
        let future = normalized
          .filter((ev) => ev.date >= now)
          .sort((a, b) => a.date - b.date)
          .slice(0, 20);

        if (future.length === 0) {
          console.warn("SpaceX data empty after cutoff, attempting SpaceDevs", {
            source,
            fetched: launches.length,
            parsed: normalized.length,
            cutoff: now.toISOString(),
          });
          try {
            const ll2Launches = await fetchSpaceXViaLl2();
            const ll2Normalized = ll2Launches
              .map((entry) => normalizeLl2Launch(entry))
              .filter(Boolean);
            future = ll2Normalized
              .filter((ev) => ev.date >= now)
              .sort((a, b) => a.date - b.date)
              .slice(0, 20);
            source = "spacedevs";
          } catch (llErr) {
            console.warn("SpaceDevs path failed", llErr);
          }
        }

        const vandenberg = future.filter((ev) => ev.isVandenberg);
        if (future.length > 0 && vandenberg.length === 0) {
          console.info(
            "Launches available but none from Vandenberg; suppressing display",
            {
              source,
              sample: future.slice(0, 3).map((ev) => ({
                title: ev.title,
                site: ev.site,
                date: ev.date.toISOString(),
              })),
            }
          );
        }

        future = vandenberg.slice(0, 2);

        if (future.length === 0) {
          console.warn("SpaceX launches fetched but none survived cutoff", {
            source,
            cutoff: now.toISOString(),
            fetched: launches.length,
            parsed: normalized.length,
          });
        } else {
          const first = future[0];
          console.info(
            "Launch schedule loaded",
            future.length,
            "from",
            source,
            "first launch",
            first.title,
            first.date.toISOString()
          );
        }

        return future;
      }

      function otherNiceThings(year) {
        return [
          {
            date: new Date(year, 5, 1, 12, 0),
            title: "First day of hurricane season",
            kind: "other",
          },
        ];
      }

      const BIRTHDAY_SHEET_URL =
        "https://docs.google.com/spreadsheets/d/1ULKdY1qGldp1UJFG3AouwNay0SbVKQ67Xnl87U1wLnQ/gviz/tq?tqx=out:csv";

      function parseCsvLine(line) {
        const pattern = /,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
        return line
          .split(pattern)
          .map((part) => part.replace(/^\"|\"$/g, "").trim());
      }

      function parseDateParts(value) {
        if (!value) return null;
        const normalized = value.replace(/-/g, "/");
        const parts = normalized.split("/").map((p) => p.trim());
        if (parts.length < 2) return null;
        const month = parseInt(parts[0], 10) - 1;
        const day = parseInt(parts[1], 10);
        const year = parts[2] ? parseInt(parts[2], 10) : null;
        if (Number.isNaN(month) || Number.isNaN(day)) return null;
        return { month, day, year };
      }

      function parseBirthdaySheet(csvText) {
        const rows = csvText
          .trim()
          .split(/\r?\n/)
          .filter((line) => line.trim())
          .map(parseCsvLine);
        const [, ...dataRows] = rows; // skip header
        return dataRows
          .map((cols) => {
            const [name, dateRaw, ageFlag] = cols;
            const dateParts = parseDateParts(dateRaw);
            if (!name || !dateParts) return null;
            return {
              name,
              month: dateParts.month,
              day: dateParts.day,
              birthYear: dateParts.year,
              ageUpdates: (ageFlag || "").toLowerCase() === "yes",
            };
          })
          .filter(Boolean);
      }

      function generateBirthdayEvents(entries, years) {
        const events = [];
        const lastYear = years[years.length - 1];
        entries.forEach((entry) => {
          const { name, month, day, birthYear, ageUpdates } = entry;
          years.forEach((year) => {
            const birthdayDate = new Date(year, month, day, 12, 0);
            events.push({
              date: birthdayDate,
              title: `${name}'s Birthday`,
              kind: "other",
            });
          });

          if (ageUpdates && birthYear) {
            const start = new Date(birthYear, month, day, 12, 0);
            const end = new Date(lastYear, 11, 31, 23, 59, 59);
            let current = new Date(start);
            let months = 0;
            while (current <= end) {
              if (months > 0) {
                events.push({
                  date: new Date(current),
                  title: `${name} is ${months} months old`,
                  kind: "other",
                });
              }
              months += 1;
              current.setMonth(current.getMonth() + 1);
            }
          }
        });
        return events;
      }

      async function fetchBirthdayEvents(years) {
        try {
          const res = await fetch(BIRTHDAY_SHEET_URL);
          if (!res.ok) throw new Error("birthday fetch failed");
          const csvText = await res.text();
          const entries = parseBirthdaySheet(csvText);
          return generateBirthdayEvents(entries, years);
        } catch (err) {
          console.warn("Birthday fetch error", err);
          return [];
        }
      }

      async function refreshEvents() {
        const now = currentTime();
        const years = [
          now.getFullYear(),
          now.getFullYear() + 1,
          now.getFullYear() + 2,
        ];

        const holidayPromises = years.map((y) => fetchHolidays(y));
        const spacerPromise = fetchSpaceXLaunches();
        const birthdayPromise = fetchBirthdayEvents(years);

        const [holidayResults, launches, birthdayEvents] = await Promise.all([
          Promise.all(holidayPromises),
          spacerPromise,
          birthdayPromise,
        ]);

        const computed = years.flatMap((y) => [
          ...calculateTimeChanges(y),
          ...seasonEvents(y),
          ...meteorShowerEvents(y),
          ...eclipseEvents(y),
          ...otherNiceThings(y),
        ]);

        eventsCache = dedupeEvents(
          [
            ...holidayResults.flat(),
            ...computed,
            ...birthdayEvents,
            ...launches,
          ].map((ev) => ({
            ...ev,
            date: new Date(ev.date),
            kind: ev.kind || "other",
          }))
        );

        renderToday();
        renderUpcoming();
        updateLaunchPulse();
      }

      const WEATHER_URL =
        "https://api.open-meteo.com/v1/forecast?latitude=34.1511&longitude=-118.4490&current_weather=true&daily=temperature_2m_max,temperature_2m_min,weathercode&timezone=America/Los_Angeles&temperature_unit=fahrenheit&forecast_days=7";

      const WEATHER_CODES = {
        0: "clear sky",
        1: "mainly clear",
        2: "partly cloudy",
        3: "overcast",
        45: "foggy",
        48: "foggy",
        51: "light drizzle",
        53: "drizzle",
        55: "heavy drizzle",
        56: "freezing drizzle",
        57: "freezing drizzle",
        61: "light rain",
        63: "rain",
        65: "heavy rain",
        66: "freezing rain",
        67: "freezing rain",
        71: "light snow",
        73: "snow",
        75: "heavy snow",
        77: "snow grains",
        80: "light showers",
        81: "showers",
        82: "heavy showers",
        85: "snow showers",
        86: "snow showers",
        95: "thunderstorm",
        96: "thunderstorm",
        99: "thunderstorm",
      };

      function weatherClass(status) {
        const s = (status || "").toLowerCase();
        if (s.includes("thunder")) return "status-thunderstorm";
        if (s.includes("rain") || s.includes("drizzle") || s.includes("shower"))
          return "status-rain";
        if (s.includes("cloud")) return "status-cloudy";
        if (s.includes("clear")) return "status-clear";
        if (s.includes("fog")) return "status-foggy";
        if (s.includes("sun")) return "status-sunny";
        return "";
      }

      function parseLocalDate(dateString) {
        if (!dateString) return null;
        const parts = dateString.split("-").map(Number);
        if (parts.length !== 3) return null;
        return new Date(parts[0], parts[1] - 1, parts[2]);
      }

      async function refreshWeather() {
        try {
          const res = await fetch(WEATHER_URL);
          if (!res.ok) throw new Error("weather fetch failed");
          const data = await res.json();
          const current = data.current_weather || {};
          const daily = data.daily || {};
          const todayStart = new Date();
          todayStart.setHours(0, 0, 0, 0);

          let todayIndex = null;
          if (daily.time && daily.time.length) {
            for (let i = 0; i < daily.time.length; i++) {
              const localDate = parseLocalDate(daily.time[i]);
              if (localDate && localDate >= todayStart) {
                todayIndex = i;
                break;
              }
            }
          }

          const highToday =
            todayIndex !== null && daily.temperature_2m_max
              ? daily.temperature_2m_max[todayIndex]
              : null;
          const lowToday =
            todayIndex !== null && daily.temperature_2m_min
              ? daily.temperature_2m_min[todayIndex]
              : null;
          const todayCode =
            todayIndex !== null && daily.weathercode
              ? daily.weathercode[todayIndex]
              : current.weathercode;
          const nowStatus = WEATHER_CODES[todayCode] || "weather";
          const nowParts = [];
          if (current.temperature !== undefined)
            nowParts.push(`${Math.round(current.temperature)}°F now`);
          nowParts.push(nowStatus);
          $weatherNow.textContent = nowParts.join(", ");
          $weatherNow.className = `list-item ${weatherClass(nowStatus)}`.trim();

          const todayParts = [];
          if (highToday !== null && lowToday !== null)
            todayParts.push(
              `high ${Math.round(highToday)}°F / low ${Math.round(lowToday)}°F`
            );
          $weatherToday.textContent = todayParts.join(", ");
          $weatherToday.className = `list-item ${weatherClass(
            nowStatus
          )}`.trim();

          const outlook = [];
          if (
            daily.time &&
            daily.temperature_2m_max &&
            daily.temperature_2m_min &&
            daily.weathercode
          ) {
            for (let i = 0; i < daily.time.length; i++) {
              const date = parseLocalDate(daily.time[i]);
              if (!date || date <= todayStart) continue;
              const label = date.toLocaleDateString(undefined, {
                weekday: "short",
              });
              const high = Math.round(daily.temperature_2m_max[i]);
              const low = Math.round(daily.temperature_2m_min[i]);
              const status = WEATHER_CODES[daily.weathercode[i]] || "weather";
              outlook.push({ label, high, low, status });
              if (outlook.length === 7) break;
            }
          }
          $weatherOutlook.innerHTML = "";
          outlook.forEach((entry) => {
            const item = document.createElement("div");
            item.className = `list-item ${weatherClass(entry.status)}`.trim();
            item.textContent = `${entry.label}: ${entry.high}°/${entry.low}° ${entry.status}`;
            $weatherOutlook.appendChild(item);
          });
        } catch (err) {
          console.warn("Weather fetch error", err);
          $weatherNow.textContent = "Weather unavailable";
          $weatherToday.textContent = "";
          $weatherOutlook.innerHTML = "";
        }
      }

      function updateLaunchPulse() {
        const now = currentTime();
        const pulseWindowMs = 60 * 60 * 1000;
        const shouldPulse = eventsCache.some(
          (ev) =>
            ev.kind === "launch" &&
            ev.isVandenberg &&
            ev.date > now &&
            ev.date - now <= pulseWindowMs
        );
        document.body.classList.toggle("vandenberg-pulse", shouldPulse);
      }

      function tick() {
        renderClock();
        updateLaunchPulse();
      }

      $nextButton.addEventListener("click", () => {
        setUpcomingPage(upcomingPage + 1);
      });

      $returnButton.addEventListener("click", () => {
        setUpcomingPage(0);
      });

      renderClock();
      refreshEvents();
      refreshWeather();
      setInterval(tick, 1000);
      setInterval(refreshEvents, 60 * 60 * 1000);
      setInterval(refreshWeather, 60 * 60 * 1000);
    </script>
  </body>
</html>
