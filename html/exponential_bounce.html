<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Exponential Bounce — v15 (Real-Time Restart, HUD, Scrollable UI)
    </title>
    <style>
      :root {
        --ui-w: 320px;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0b1020;
        color: #e6e6e6;
        overflow: hidden;
      }
      #wrap {
        display: flex;
        height: 100%;
        overflow: hidden;
      }

      /* Sidebar */
      #ui {
        width: var(--ui-w);
        display: flex;
        flex-direction: column;
        height: 100vh;
        box-sizing: border-box;
        border-right: 1px solid #1b233d;
        background: linear-gradient(180deg, #0f1530, #0b1020 40%);
      }
      #ui header {
        padding: 12px 16px 8px;
        border-bottom: 1px solid #1b233d;
      }
      #ui h1 {
        font-size: 18px;
        margin: 0;
        letter-spacing: 0.3px;
      }

      /* Top actions pinned */
      #topActions {
        padding: 12px 16px;
        display: grid;
        gap: 8px;
        position: relative;
      }
      .btnWrap {
        position: relative;
      }
      .countdownBadge {
        position: absolute;
        right: 8px;
        top: -10px;
        background: #0ea5e9;
        color: #001018;
        font-weight: 900;
        border-radius: 999px;
        padding: 4px 8px;
        font-size: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        display: none;
      }
      button.big {
        width: 100%;
        padding: 14px 12px;
        margin-top: 0;
        font-size: 16px;
        font-weight: 700;
        border: 0;
        border-radius: 12px;
        color: white;
        cursor: pointer;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      }
      #reset {
        background: #2563eb;
      }
      #stop {
        background: #d82424;
      }

      /* Scrollable controls */
      #controlsScroll {
        padding: 10px 16px 16px;
        overflow-y: auto;
        flex: 1 1 auto;
      }
      .sectionTitle {
        font-size: 13px;
        opacity: 0.75;
        margin: 10px 0 6px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .field {
        margin: 12px 0;
      }
      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .row label {
        font-size: 13px;
        opacity: 0.9;
      }
      .row output {
        font-variant-numeric: tabular-nums;
      }
      input[type="range"] {
        width: 100%;
      }
      #spawnCtl {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      #spawnCtl input[type="number"] {
        width: 72px;
      }
      hr {
        border: none;
        border-top: 1px solid #1b233d;
        margin: 12px 0;
      }

      /* Game area */
      #stageWrap {
        position: relative;
        flex: 1;
        width: calc(100% - var(--ui-w));
        height: 100%;
      }
      #canvas {
        position: absolute;
        inset: 0;
        display: block;
        background: #000;
      }

      /* HUD (top-right) */
      #hud {
        position: absolute;
        right: 12px;
        top: 10px;
        z-index: 3;
        display: grid;
        gap: 6px;
        text-align: right;
      }
      #geneStats {
        display: grid;
        gap: 2px;
        justify-items: end;
      }
      .geneRow {
        font-weight: 800;
        font-size: 12px;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }
      #hudCountdown {
        justify-self: end;
        background: rgba(14, 165, 233, 0.15);
        border: 1px solid rgba(14, 165, 233, 0.5);
        padding: 4px 8px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 800;
        display: none;
      }

      /* Start overlay */
      #startOverlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(2px);
        z-index: 2;
      }
      #startOverlay .startBtn {
        cursor: pointer;
        border: 0;
        border-radius: 16px;
        padding: 18px 28px;
        font-weight: 900;
        font-size: 22px;
        background: #22c55e;
        color: #06220f;
        box-shadow: 0 10px 30px rgba(34, 197, 94, 0.4);
      }
      .hint {
        position: absolute;
        bottom: 16px;
        left: 16px;
        right: 16px;
        text-align: center;
        font-size: 12px;
        opacity: 0.75;
      }

      /* MOBILE: overlay panel; canvas never resizes when panel opens */
      #openControls {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 4;
        display: none;
        background: #374151;
        color: #fff;
        border: 0;
        border-radius: 12px;
        padding: 10px 12px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }
      #mobileStop {
        position: fixed;
        left: 12px;
        bottom: 12px;
        z-index: 4;
        display: none;
        background: #d82424;
        color: #fff;
        border: 0;
        border-radius: 12px;
        padding: 10px 12px;
        font-weight: 800;
        cursor: pointer;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }

      @media (max-width: 900px) {
        #stageWrap {
          width: 100% !important;
        }
        #ui {
          position: fixed;
          left: 0;
          top: 0;
          height: 100vh;
          width: var(--ui-w);
          border-right: 1px solid rgba(27, 35, 61, 0.6);
          background: rgba(15, 21, 48, 0.92);
          backdrop-filter: blur(4px);
          transform: translateX(-100%);
          transition: transform 0.25s ease;
          z-index: 5;
        }
        body.sidebar-open #ui {
          transform: translateX(0);
        }
        #openControls,
        #mobileStop {
          display: inline-block;
        }
      }

      #closeOverlay {
        display: none;
      }
      @media (max-width: 900px) {
        #closeOverlay {
          display: inline-block;
          width: 100%;
          padding: 10px 12px;
          margin: 0 0 8px 0;
          border: 0;
          border-radius: 10px;
          cursor: pointer;
          font-weight: 800;
          color: #0b1020;
          background: #93c5fd;
        }
      }
    </style>
  </head>
  <body>
    <!-- Mobile overlay controls -->
    <button id="openControls" aria-label="Open controls">☰ Settings</button>
    <button id="mobileStop" aria-label="Stop game">Stop</button>

    <div id="wrap">
      <aside id="ui" aria-label="Controls sidebar">
        <header><h1>Exponential Bounce</h1></header>
        <div id="topActions">
          <button
            id="closeOverlay"
            aria-label="Close controls"
            style="display: none"
          >
            Close ✕
          </button>
          <div class="btnWrap">
            <button id="reset" class="big">RESET</button>
            <div id="cdReset" class="countdownBadge"></div>
          </div>
          <div class="btnWrap">
            <button id="stop" class="big">STOP</button>
            <div id="cdStop" class="countdownBadge"></div>
          </div>
        </div>

        <div id="controlsScroll">
          <div class="sectionTitle">Auto-Restart</div>
          <div class="field">
            <div class="row">
              <label for="autoRestart">Enable auto-restart at count ≥</label
              ><output id="autoThOut"></output>
            </div>
            <div class="row" style="gap: 12px">
              <label style="display: flex; align-items: center; gap: 8px"
                ><input id="autoRestart" type="checkbox" />Enable</label
              >
              <input id="autoThreshold" type="range" />
            </div>
          </div>
          <hr />

          <div class="sectionTitle">Physics & Spawn</div>
          <div class="field">
            <div class="row">
              <label for="gravity">Gravity</label><output id="gOut"></output>
            </div>
            <input id="gravity" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="bounce">Bounce (restitution)</label
              ><output id="bOut"></output>
            </div>
            <input id="bounce" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label>Spawn per fall</label><output id="mOut"></output>
            </div>
            <div id="spawnCtl">
              <input id="mult" type="range" /><input
                id="multNum"
                type="number"
              />
            </div>
          </div>
          <hr />

          <div class="sectionTitle">Sieve & Speed</div>
          <div class="field">
            <div class="row">
              <label for="gap">Hole width (px)</label
              ><output id="gapOut"></output>
            </div>
            <input id="gap" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="sieveH">Sieve thickness (px)</label
              ><output id="sieveHOut"></output>
            </div>
            <input id="sieveH" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="spd">Line speed ×</label><output id="spdOut"></output>
            </div>
            <input id="spd" type="range" />
          </div>
          <hr />

          <div class="sectionTitle">Genetics & Visuals</div>
          <div class="field">
            <div class="row">
              <label for="colMut">Genetic color variation ×</label
              ><output id="colMutOut"></output>
            </div>
            <input id="colMut" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="sizeMut">Genetic size variation ×</label
              ><output id="sizeMutOut"></output>
            </div>
            <input id="sizeMut" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="rMin">Start size min (px)</label
              ><output id="rMinOut"></output>
            </div>
            <input id="rMin" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="rMax">Start size max (px)</label
              ><output id="rMaxOut"></output>
            </div>
            <input id="rMax" type="range" />
          </div>
          <div class="field">
            <div class="row">
              <label for="trailLen">Trail length</label
              ><output id="trailOut"></output>
            </div>
            <input id="trailLen" type="range" />
          </div>
          <div style="font-size: 12px; opacity: 0.7; margin-top: 8px">
            Tip: click/tap canvas to enable audio.
          </div>
        </div>
      </aside>

      <div id="stageWrap">
        <canvas id="canvas"></canvas>
        <div id="hud">
          <div id="geneStats"></div>
          <div id="hudCountdown"></div>
        </div>
        <div id="startOverlay">
          <div>
            <button class="startBtn" id="startBtn">START</button>
            <div class="hint">
              Spawns the first 3 squares. Lines move; squares multiply when they
              exit the bottom.
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* ==============================
     CONFIG — defaults match prior build
     ============================== */
      const CONFIG = {
        // Simulation caps & timing
        maxBalls: 5000,
        maxDt: 0.033,
        dprMin: 1,
        dprMax: 2,

        // Boundaries & walls
        wallThicknessPx: 2,
        topPaddingY: 60,

        // Ball physics
        dragVX: 0.02,
        dragVY: 0.01,
        restitutionDefault: 0.95,

        // Size genetics (logical px BEFORE DPR)
        ballRadiusBaseMin: 4,
        ballRadiusBaseMax: 30,
        ballRadiusMutationPct: 0.1,
        ballRadiusHardMin: 1.1,

        // Color genetics (HSL)
        hueMutationRange: 8,
        satMutationRange: 5,
        lightMutationRange: 4,
        satClamp: [45, 95],
        lightClamp: [40, 80],

        // Sieve (moving dotted lines)
        sieveTopYFactor: 0.5,
        sieveBottomBaseOffset: 160,
        sieveRowGapPx: 34,
        sieveHeightPx: 20, // UI label: Sieve thickness
        sieveSolidSegPx: 78,
        sieveBaseSpeedsPxPerSec: [14, 22, 30, 38],

        // Audio
        audioMasterGain: 0.08,
        audioSilenceBelowSpeed: 220,
        audioMaxSpeed: 1400,
        audioFreqBase: 140,
        audioFreqRange: 900,
        audioEnvPeakMin: 0.15,
        audioEnvPeakScale: 0.55,

        // Particles (glitter)
        particleCountSpawn: 26,
        particleSpeedMin: 40,
        particleSpeedMax: 180,
        particleSizeMin: 2,
        particleSizeMax: 4,
        particleLifeMin: 0.5,
        particleLifeMax: 2.2,
        particleGravityFactor: 0.2,
        particleDampingVX: 0.1,
        particleDampingVY: 0.06,

        // Trails
        trailLength: 12,

        // UI ranges (min,max,step,value)
        uiGravity: { min: 200, max: 2400, step: 50, value: 1200 },
        uiBounce: { min: 0.3, max: 0.99, step: 0.01, value: 0.95 },
        uiSpawnPerFall: { min: 2, max: 10, step: 1, value: 2 },
        uiHoleWidth: { min: 4, max: 600, step: 2, value: 80 },
        uiSpeedMul: { min: 0.0, max: 8.0, step: 0.05, value: 1.0 },

        // New tunable ranges (scaled 0..4× defaults)
        uiColorMutMul: { min: 0, max: 4, step: 0.01, value: 1 },
        uiSizeMutMul: { min: 0, max: 4, step: 0.01, value: 1 },
        uiRMin: { min: 0, max: 4 * 4, step: 0.1, value: 4 },
        uiRMax: { min: 0, max: 4 * 30, step: 0.1, value: 30 },
        uiTrailLen: { min: 0, max: 4 * 12, step: 1, value: 12 },
        uiSieveH: { min: 0, max: 4 * 20, step: 1, value: 20 },

        // Auto-restart
        autoRestartEnabled: false,
        autoRestartSeconds: 10,
        autoRestartThresholdDefault: 5000,
        uiAutoThreshold: { min: 100, max: 5000, step: 10, value: 5000 },
      };

      (() => {
        // ===== Canvas & DOM =====
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const startOverlay = document.getElementById("startOverlay");
        const startBtn = document.getElementById("startBtn");

        let W, H, DPR;
        let started = false;

        const ui = {
          gravity: el("gravity"),
          gOut: el("gOut"),
          bounce: el("bounce"),
          bOut: el("bOut"),
          mult: el("mult"),
          multNum: el("multNum"),
          mOut: el("mOut"),
          gap: el("gap"),
          gapOut: el("gapOut"),
          sieveH: el("sieveH"),
          sieveHOut: el("sieveHOut"),
          spd: el("spd"),
          spdOut: el("spdOut"),

          colMut: el("colMut"),
          colMutOut: el("colMutOut"),
          sizeMut: el("sizeMut"),
          sizeMutOut: el("sizeMutOut"),
          rMin: el("rMin"),
          rMinOut: el("rMinOut"),
          rMax: el("rMax"),
          rMaxOut: el("rMaxOut"),
          trailLen: el("trailLen"),
          trailOut: el("trailOut"),

          autoRestart: el("autoRestart"),
          autoThreshold: el("autoThreshold"),
          autoThOut: el("autoThOut"),
          reset: el("reset"),
          stop: el("stop"),
          cdReset: el("cdReset"),
          cdStop: el("cdStop"),

          openControls: el("openControls"),
          closeOverlay: el("closeOverlay"),
          mobileStop: el("mobileStop"),

          hudCountdown: el("hudCountdown"),
          geneStats: el("geneStats"),
        };
        function el(id) {
          return document.getElementById(id);
        }

        // Apply ranges
        function applyRange(input, spec, isNumber = false) {
          input.min = spec.min;
          input.max = spec.max;
          input.step = spec.step;
          input.value = spec.value;
          if (isNumber) {
            input.min = spec.min;
            input.max = spec.max;
            input.step = spec.step;
            input.value = spec.value;
          }
        }
        applyRange(ui.gravity, CONFIG.uiGravity);
        applyRange(ui.bounce, CONFIG.uiBounce);
        applyRange(ui.mult, CONFIG.uiSpawnPerFall);
        applyRange(ui.multNum, CONFIG.uiSpawnPerFall, true);
        applyRange(ui.gap, CONFIG.uiHoleWidth);
        applyRange(ui.sieveH, CONFIG.uiSieveH);
        applyRange(ui.spd, CONFIG.uiSpeedMul);
        applyRange(ui.colMut, CONFIG.uiColorMutMul);
        applyRange(ui.sizeMut, CONFIG.uiSizeMutMul);
        applyRange(ui.rMin, CONFIG.uiRMin);
        applyRange(ui.rMax, CONFIG.uiRMax);
        applyRange(ui.trailLen, CONFIG.uiTrailLen);
        ui.autoRestart.checked = CONFIG.autoRestartEnabled;
        applyRange(ui.autoThreshold, CONFIG.uiAutoThreshold);

        // Derived state from UI
        let gravity = +ui.gravity.value;
        let restitution = +ui.bounce.value;
        let spawnMultiplier = +ui.mult.value;
        let holeWidthPX = +ui.gap.value;
        let sieveHeightPX = +ui.sieveH.value;
        let speedMul = +ui.spd.value;

        let colorMutMul = +ui.colMut.value;
        let sizeMutMul = +ui.sizeMut.value;
        let startRMin = +ui.rMin.value;
        let startRMax = +ui.rMax.value;
        let TRAIL_LEN = +ui.trailLen.value;

        let autoEnabled = ui.autoRestart.checked;
        let autoThreshold = +ui.autoThreshold.value;
        const AUTO_SECONDS = CONFIG.autoRestartSeconds;
        let countingDown = false;
        let countdownDeadline = null; // real clock deadline (performance.now())

        // ===== World =====
        const balls = [];
        const particles = [];
        const WALL_THICK = CONFIG.wallThicknessPx;
        const ORIGINAL_SPAWNS = [];
        const TOP_Y = () => CONFIG.topPaddingY * DPR;

        // Genealogy: 3 roots
        const ROOT_COUNT = 3;
        const rootColors = new Array(ROOT_COUNT);
        const rootStats = new Array(ROOT_COUNT).fill(0);

        // ===== Sieve Lines =====
        const sieves = [];
        function placeSieves() {
          sieves.length = 0;
          const bottomBase = H - CONFIG.sieveBottomBaseOffset * DPR;
          const topY = CONFIG.sieveTopYFactor * H;
          const thickness = sieveHeightPX * DPR;
          const seg = CONFIG.sieveSolidSegPx * DPR;
          const gap = holeWidthPX * DPR;
          const rowGap = CONFIG.sieveRowGapPx * DPR;
          const y0 = topY;
          const y3 = bottomBase + 3 * rowGap;
          const y1 = y0 + ((y3 - y0) * 1) / 3;
          const y2 = y0 + ((y3 - y0) * 2) / 3;
          const ys = [y0, y1, y2, y3];
          const base = CONFIG.sieveBaseSpeedsPxPerSec;
          for (let i = 0; i < 4; i++) {
            sieves.push({
              index: i,
              y: ys[i],
              height: thickness,
              seg,
              gap,
              phase: Math.random() * 1000,
              speedBase: base[i] * DPR,
              dir: i % 2 === 0 ? 1 : -1,
            });
          }
        }

        function resize() {
          DPR = Math.max(
            CONFIG.dprMin,
            Math.min(CONFIG.dprMax, window.devicePixelRatio || 1)
          );
          const isMobile = window.matchMedia("(max-width: 900px)").matches;
          const uiW = isMobile ? 0 : document.getElementById("ui").offsetWidth;
          canvas.width = Math.floor((window.innerWidth - uiW) * DPR);
          canvas.height = Math.floor(window.innerHeight * DPR);
          canvas.style.width = canvas.width / DPR + "px";
          canvas.style.height = canvas.height / DPR + "px";
          W = canvas.width;
          H = canvas.height;
          ORIGINAL_SPAWNS.length = 0;
          ORIGINAL_SPAWNS.push(0.3 * W, 0.5 * W, 0.7 * W);
          placeSieves();
        }
        window.addEventListener(
          "resize",
          () => {
            resize();
            syncUI();
          },
          { passive: true }
        );
        resize();

        // Mobile overlay toggle
        function openPanel() {
          document.body.classList.add("sidebar-open");
          ui.closeOverlay.style.display = "inline-block";
        }
        function closePanel() {
          document.body.classList.remove("sidebar-open");
          ui.closeOverlay.style.display = "none";
        }
        ui.openControls.addEventListener("click", openPanel);
        ui.closeOverlay.addEventListener("click", closePanel);

        // ===== Color helpers (HSL) =====
        function randBrightHSL() {
          return {
            h: Math.floor(Math.random() * 360),
            s: 65 + Math.random() * 20,
            l: 55 + Math.random() * 8,
          };
        }
        function hslToCss(c) {
          return `hsl(${((c.h % 360) + 360) % 360} ${c.s}% ${c.l}%)`;
        }
        function mutateColor(c) {
          const hueR = CONFIG.hueMutationRange * colorMutMul;
          const satR = CONFIG.satMutationRange * colorMutMul;
          const ligR = CONFIG.lightMutationRange * colorMutMul;
          const sat = clamp(
            c.s + (Math.random() * 2 * satR - satR),
            CONFIG.satClamp[0],
            CONFIG.satClamp[1]
          );
          const light = clamp(
            c.l + (Math.random() * 2 * ligR - ligR),
            CONFIG.lightClamp[0],
            CONFIG.lightClamp[1]
          );
          return {
            h: c.h + (Math.random() * 2 * hueR - hueR),
            s: sat,
            l: light,
          };
        }

        // Size genetics (logical px)
        function randomBaseRadiusPx() {
          const a = startRMin,
            b = Math.max(startRMin, startRMax);
          return a + Math.random() * (b - a);
        }
        function mutateRadiusPx(r) {
          const pct = CONFIG.ballRadiusMutationPct * sizeMutMul;
          const f = 1 + (Math.random() * 2 * pct - pct);
          const nr = r * f;
          return nr > CONFIG.ballRadiusHardMin ? nr : CONFIG.ballRadiusHardMin;
        }

        // Utils
        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }

        function addBallAt(x, y, colorHSL, baseRadiusPx, rootId) {
          const geneR = baseRadiusPx ?? randomBaseRadiusPx();
          const r = geneR * DPR;
          balls.push({
            x,
            y,
            vx: (Math.random() * 120 - 60) * DPR,
            vy: Math.random() * -30 * DPR,
            r,
            geneR,
            color: colorHSL || randBrightHSL(),
            trail: [],
            rootId,
          });
        }

        function emitGlitter(
          x,
          y,
          count = CONFIG.particleCountSpawn,
          hueBase = Math.random() * 360
        ) {
          for (let i = 0; i < count; i++) {
            const a = Math.random() * Math.PI * 2;
            const sp =
              (CONFIG.particleSpeedMin +
                Math.random() *
                  (CONFIG.particleSpeedMax - CONFIG.particleSpeedMin)) *
              DPR;
            particles.push({
              x,
              y,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp - 60 * DPR,
              life:
                CONFIG.particleLifeMin +
                Math.random() *
                  (CONFIG.particleLifeMax - CONFIG.particleLifeMin),
              age: 0,
              size:
                CONFIG.particleSizeMin +
                Math.random() *
                  (CONFIG.particleSizeMax - CONFIG.particleSizeMin),
              hue: (hueBase + Math.random() * 40) % 360,
            });
          }
        }

        function seed() {
          balls.length = 0;
          particles.length = 0;
          countingDown = false;
          countdownDeadline = null;
          setCountdownBadges(null);
          setHudCountdown(null);
          for (let i = 0; i < ROOT_COUNT; i++) rootStats[i] = 0;
          for (let i = 0; i < ROOT_COUNT; i++) {
            const x = ORIGINAL_SPAWNS[i];
            const y = TOP_Y() + i * 6 * DPR;
            const c = randBrightHSL();
            rootColors[i] = c;
            addBallAt(x, y, c, randomBaseRadiusPx(), i);
            emitGlitter(x, y, CONFIG.particleCountSpawn, c.h);
          }
        }

        function toStartScreen() {
          started = false;
          balls.length = 0;
          particles.length = 0;
          countingDown = false;
          countdownDeadline = null;
          setCountdownBadges(null);
          setHudCountdown(null);
          startOverlay.style.display = "flex";
        }

        // ===== UI wiring =====
        function syncUI() {
          ui.gOut.textContent = Math.round(gravity);
          ui.bOut.textContent = (+restitution).toFixed(2);
          ui.mOut.textContent = spawnMultiplier;
          ui.mult.value = spawnMultiplier;
          ui.multNum.value = spawnMultiplier;
          ui.gapOut.textContent = Math.round(holeWidthPX);
          ui.sieveHOut.textContent = Math.round(sieveHeightPX);
          ui.spdOut.textContent = (+speedMul).toFixed(2);
          ui.colMutOut.textContent = (+colorMutMul).toFixed(2);
          ui.sizeMutOut.textContent = (+sizeMutMul).toFixed(2);
          ui.rMinOut.textContent = (+startRMin).toFixed(1);
          ui.rMaxOut.textContent = (+startRMax).toFixed(1);
          ui.trailOut.textContent = TRAIL_LEN;
          ui.autoThOut.textContent = autoThreshold;
          renderGeneStats();
        }

        ui.gravity.addEventListener("input", (e) => {
          gravity = +e.target.value;
          ui.gOut.textContent = Math.round(gravity);
        });
        ui.bounce.addEventListener("input", (e) => {
          restitution = +e.target.value;
          ui.bOut.textContent = (+restitution).toFixed(2);
        });
        const setMult = (v) => {
          const n = clamp(
            Math.round(+v || CONFIG.uiSpawnPerFall.value),
            CONFIG.uiSpawnPerFall.min,
            CONFIG.uiSpawnPerFall.max
          );
          spawnMultiplier = n;
          ui.mOut.textContent = n;
          ui.mult.value = n;
          ui.multNum.value = n;
        };
        ui.mult.addEventListener("input", (e) => setMult(e.target.value));
        ui.multNum.addEventListener("input", (e) => setMult(e.target.value));
        ui.gap.addEventListener("input", (e) => {
          holeWidthPX = +e.target.value;
          ui.gapOut.textContent = Math.round(holeWidthPX);
          for (const sv of sieves) sv.gap = holeWidthPX * DPR;
        });
        ui.sieveH.addEventListener("input", (e) => {
          sieveHeightPX = +e.target.value;
          ui.sieveHOut.textContent = Math.round(sieveHeightPX);
          placeSieves();
        });
        ui.spd.addEventListener("input", (e) => {
          speedMul = +e.target.value;
          ui.spdOut.textContent = (+speedMul).toFixed(2);
        });
        ui.colMut.addEventListener("input", (e) => {
          colorMutMul = +e.target.value;
          ui.colMutOut.textContent = (+colorMutMul).toFixed(2);
        });
        ui.sizeMut.addEventListener("input", (e) => {
          sizeMutMul = +e.target.value;
          ui.sizeMutOut.textContent = (+sizeMutMul).toFixed(2);
        });
        ui.rMin.addEventListener("input", (e) => {
          startRMin = +e.target.value;
          if (startRMin > startRMax) {
            startRMax = startRMin;
            ui.rMax.value = startRMax;
          }
          syncUI();
        });
        ui.rMax.addEventListener("input", (e) => {
          startRMax = +e.target.value;
          if (startRMax < startRMin) {
            startRMin = startRMax;
            ui.rMin.value = startRMin;
          }
          syncUI();
        });
        ui.trailLen.addEventListener("input", (e) => {
          TRAIL_LEN = Math.round(+e.target.value);
          ui.trailOut.textContent = TRAIL_LEN;
        });

        ui.autoRestart.addEventListener("change", (e) => {
          autoEnabled = e.target.checked;
          if (!autoEnabled) {
            countingDown = false;
            countdownDeadline = null;
            setCountdownBadges(null);
            setHudCountdown(null);
          }
        });
        ui.autoThreshold.addEventListener("input", (e) => {
          autoThreshold = +e.target.value;
          ui.autoThOut.textContent = autoThreshold;
        });

        ui.reset.addEventListener("click", () => {
          if (!started) {
            started = true;
            startOverlay.style.display = "none";
          }
          seed();
          syncUI();
        });
        ui.stop.addEventListener("click", () => {
          toStartScreen();
          syncUI();
        });
        ui.mobileStop.addEventListener("click", () => {
          toStartScreen();
          syncUI();
        });

        startBtn.addEventListener("click", () => {
          started = true;
          startOverlay.style.display = "none";
          seed();
          syncUI();
          initAudio();
        });

        // ===== Audio =====
        let AC = null,
          masterGain = null;
        function initAudio() {
          try {
            if (!AC) {
              AC = new (window.AudioContext || window.webkitAudioContext)();
              masterGain = AC.createGain();
              masterGain.gain.value = CONFIG.audioMasterGain;
              masterGain.connect(AC.destination);
            }
            if (AC.state === "suspended") AC.resume();
          } catch (e) {}
        }
        window.addEventListener("pointerdown", initAudio, { passive: true });
        canvas.addEventListener("pointerdown", initAudio, { passive: true });

        const oscTypes = ["sine", "triangle", "square", "sawtooth"];
        function playHit(sieveIndex, speed) {
          if (!AC || !masterGain) return;
          if (speed < CONFIG.audioSilenceBelowSpeed) return;
          const t = AC.currentTime;
          const clamped = Math.min(
            CONFIG.audioMaxSpeed,
            Math.max(CONFIG.audioSilenceBelowSpeed, speed)
          );
          const norm =
            (clamped - CONFIG.audioSilenceBelowSpeed) /
            (CONFIG.audioMaxSpeed - CONFIG.audioSilenceBelowSpeed);
          const freq = CONFIG.audioFreqBase + norm * CONFIG.audioFreqRange;
          const peak =
            CONFIG.audioEnvPeakMin +
            Math.pow(norm, 1.3) * CONFIG.audioEnvPeakScale;
          if (sieveIndex === 2) {
            const gainEnv = AC.createGain();
            gainEnv.gain.value = 0;
            gainEnv.connect(masterGain);
            const bufferSize = 2 * AC.sampleRate;
            const noiseBuffer = AC.createBuffer(1, bufferSize, AC.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++)
              output[i] = Math.random() * 2 - 1;
            const noise = AC.createBufferSource();
            noise.buffer = noiseBuffer;
            const bp = AC.createBiquadFilter();
            bp.type = "bandpass";
            bp.frequency.value = freq;
            bp.Q.value = 8;
            noise.connect(bp);
            bp.connect(gainEnv);
            gainEnv.gain.setValueAtTime(0, t);
            gainEnv.gain.linearRampToValueAtTime(peak, t + 0.006);
            gainEnv.gain.exponentialRampToValueAtTime(0.0001, t + 0.2);
            noise.start(t);
            noise.stop(t + 0.22);
            return;
          }
          const gainEnv = AC.createGain();
          gainEnv.gain.value = 0;
          gainEnv.connect(masterGain);
          const osc = AC.createOscillator();
          osc.type = oscTypes[sieveIndex % oscTypes.length];
          osc.frequency.value = freq;
          osc.detune.value = (sieveIndex - 1.5) * 8;
          osc.connect(gainEnv);
          gainEnv.gain.setValueAtTime(0, t);
          gainEnv.gain.linearRampToValueAtTime(peak, t + 0.01);
          gainEnv.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);
          osc.start(t);
          osc.stop(t + 0.28);
        }

        // ===== Physics helpers =====
        function collideWalls(b) {
          const t = CONFIG.wallThicknessPx * DPR;
          if (b.x - b.r < t) {
            b.x = t + b.r;
            b.vx = Math.abs(b.vx) * restitution;
          }
          if (b.x + b.r > W - t) {
            b.x = W - t - b.r;
            b.vx = -Math.abs(b.vx) * restitution;
          }
          if (b.y - b.r < t) {
            b.y = t + b.r;
            b.vy = Math.abs(b.vy) * restitution;
          }
        }

        function sieveBlocks(sv, x, r) {
          const period = sv.seg + sv.gap;
          const u = (((x + sv.phase) % period) + period) % period;
          if (u < sv.seg) return true;
          const leftMargin = u - sv.seg;
          const rightMargin = sv.seg + sv.gap - u;
          return leftMargin <= r || rightMargin <= r;
        }

        function collideSieveForBall(b) {
          for (const sv of sieves) {
            const top = sv.y,
              bottom = sv.y + sv.height;
            if (
              b.y + b.r >= top &&
              b.y - b.r <= bottom &&
              sieveBlocks(sv, b.x, b.r)
            ) {
              const penTop = b.y + b.r - top;
              const penBot = bottom - (b.y - b.r);
              if (penTop < penBot && b.vy >= 0) {
                b.y -= penTop + 0.5;
                const vyBefore = b.vy;
                b.vy = -Math.abs(b.vy) * restitution;
                b.vx *= 0.995;
                const impactSpeed = Math.hypot(b.vx, vyBefore);
                playHit(sv.index, impactSpeed);
              } else if (b.vy <= 0) {
                b.y += penBot + 0.5;
                const vyBefore = b.vy;
                b.vy = Math.abs(b.vy) * restitution;
                b.vx *= 0.995;
                const impactSpeed = Math.hypot(b.vx, vyBefore);
                playHit(sv.index, Math.abs(impactSpeed));
              }
            }
          }
        }

        function integrate(b, dt) {
          b.vy += gravity * dt;
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.trail.push({ x: b.x, y: b.y, r: b.r });
          if (b.trail.length > TRAIL_LEN) b.trail.shift();
          b.vx *= 1 - CONFIG.dragVX * dt;
          b.vy *= 1 - CONFIG.dragVY * dt;
        }

        function spawnFromDeath(
          parentX,
          parentColor,
          parentRadiusPx,
          n,
          rootId
        ) {
          if (balls.length >= CONFIG.maxBalls) return;
          for (let i = 0; i < n && balls.length < CONFIG.maxBalls; i++) {
            const x = parentX;
            const y = TOP_Y();
            const childColor = mutateColor(parentColor);
            const childRpx = mutateRadiusPx(parentRadiusPx);
            addBallAt(x, y, childColor, childRpx, rootId);
            emitGlitter(x, y, CONFIG.particleCountSpawn, childColor.h);
          }
        }

        // ===== Drawing helpers (rounded squares) =====
        function fillRoundedRect(x, y, w, h, r) {
          const rr = Math.min(r, Math.min(w, h) * 0.5);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
          ctx.fill();
        }

        // ===== HUD: gene stats & countdown =====
        function renderGeneStats() {
          ui.geneStats.innerHTML = "";
          for (let i = 0; i < ROOT_COUNT; i++) {
            const div = document.createElement("div");
            div.className = "geneRow";
            const col = hslToCss(rootColors[i] || { h: 0, s: 0, l: 80 });
            div.style.color = col;
            div.textContent = `Square ${i + 1}: ${rootStats[i]}`;
            ui.geneStats.appendChild(div);
          }
        }
        function setHudCountdown(secs) {
          if (secs == null) {
            ui.hudCountdown.style.display = "none";
            return;
          }
          const s = Math.max(0, Math.ceil(secs));
          ui.hudCountdown.textContent = `Restart in ${s}s`;
          ui.hudCountdown.style.display = "inline-block";
        }

        // ===== Button badges =====
        function setCountdownBadges(secs) {
          if (secs == null) {
            ui.cdReset.style.display = "none";
            ui.cdStop.style.display = "none";
            return;
          }
          const s = Math.max(0, Math.ceil(secs));
          const txt = `Restart in ${s}s`;
          ui.cdReset.textContent = txt;
          ui.cdStop.textContent = txt;
          ui.cdReset.style.display = "block";
          ui.cdStop.style.display = "block";
        }

        // ===== Main loop =====
        let last = performance.now();
        function frame(now) {
          const dt = Math.min(CONFIG.maxDt, (now - last) / 1000);
          last = now;

          for (const sv of sieves)
            sv.phase += sv.speedBase * speedMul * sv.dir * dt;

          // particles
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.age += dt;
            if (p.age >= p.life) {
              particles.splice(i, 1);
              continue;
            }
            p.vy += gravity * CONFIG.particleGravityFactor * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 1 - CONFIG.particleDampingVX * dt;
            p.vy *= 1 - CONFIG.particleDampingVY * dt;
          }

          if (started) {
            // physics
            for (let i = balls.length - 1; i >= 0; i--) {
              const b = balls[i];
              integrate(b, dt);
              collideWalls(b);
              collideSieveForBall(b);
              if (b.y - b.r > H + 4 * DPR) {
                const parentX = b.x,
                  parentColor = b.color,
                  parentRpx = b.geneR,
                  rid = b.rootId;
                balls.splice(i, 1);
                spawnFromDeath(
                  parentX,
                  parentColor,
                  parentRpx,
                  spawnMultiplier,
                  rid
                );
              }
            }

            // genealogy counts
            for (let i = 0; i < ROOT_COUNT; i++) rootStats[i] = 0;
            for (const b of balls) {
              if (b.rootId >= 0 && b.rootId < ROOT_COUNT) rootStats[b.rootId]++;
            }

            // auto-restart logic using REAL TIME
            if (autoEnabled && !countingDown && balls.length >= autoThreshold) {
              countingDown = true;
              countdownDeadline = performance.now() + AUTO_SECONDS * 1000;
            }
            if (countingDown) {
              const remaining = Math.max(
                0,
                (countdownDeadline - performance.now()) / 1000
              );
              setCountdownBadges(remaining);
              setHudCountdown(remaining);
              if (remaining <= 0) {
                if (!started) {
                  started = true;
                  startOverlay.style.display = "none";
                }
                seed();
                syncUI();
                countingDown = false;
                countdownDeadline = null;
                setCountdownBadges(null);
                setHudCountdown(null);
              }
            }
          }

          // ===== Draw =====
          ctx.clearRect(0, 0, W, H);

          // Border walls
          const t = CONFIG.wallThicknessPx * DPR;
          ctx.fillStyle = "#101937";
          ctx.fillRect(0, 0, t, H);
          ctx.fillRect(W - t, 0, t, H);
          ctx.fillRect(0, 0, W, t);
          ctx.strokeStyle = "#243068";
          ctx.lineWidth = 1 * DPR;
          ctx.beginPath();
          ctx.moveTo(t + 0.5, t + 0.5);
          ctx.lineTo(W - t - 0.5, t + 0.5);
          ctx.moveTo(t + 0.5, t + 0.5);
          ctx.lineTo(t + 0.5, H - 0.5);
          ctx.moveTo(W - t - 0.5, t + 0.5);
          ctx.lineTo(W - t - 0.5, H - 0.5);
          ctx.stroke();

          // Sieve rows
          for (const sv of sieves) {
            const period = sv.seg + sv.gap;
            const startX = -((sv.phase % period) + period) % period;
            const y = Math.round(sv.y) + 0.5;
            ctx.fillStyle = "#263372";
            for (let x = startX; x < W; x += period) {
              const w = Math.min(sv.seg, W - x);
              if (w <= 0) continue;
              ctx.fillRect(
                Math.round(x) + 0.5,
                y,
                Math.round(w),
                Math.round(sv.height)
              );
            }
            ctx.fillStyle = "#122058";
            for (let x = startX + sv.seg; x < W; x += period) {
              const w = Math.min(sv.gap, W - x);
              if (w <= 0) continue;
              const dotW = 6 * DPR,
                gapW = 6 * DPR;
              for (let dx = 0; dx < w; dx += dotW + gapW) {
                ctx.fillRect(
                  Math.round(x + dx) + 0.5,
                  y + sv.height * 0.33,
                  Math.min(dotW, w - dx),
                  sv.height * 0.34
                );
              }
            }
          }

          // Particles
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          for (const p of particles) {
            const alpha = 1 - p.age / p.life;
            ctx.fillStyle = `hsla(${p.hue} 80% 60% / ${alpha.toFixed(3)})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // Squares + trails
          for (const b of balls) {
            for (let i = 0; i < b.trail.length - 1; i++) {
              const a = (i + 1) / b.trail.length;
              const p = b.trail[i];
              const side = p.r * 2;
              const tlx = p.x - p.r;
              const tly = p.y - p.r;
              const col = hslToCss(b.color)
                .replace("hsl", "hsla")
                .replace("%)", `% / ${(0.03 + 0.12 * a).toFixed(3)})`);
              ctx.fillStyle = col;
              fillRoundedRect(tlx, tly, side, side, p.r * 0.25);
            }
            const side = b.r * 2,
              x0 = b.x - b.r,
              y0 = b.y - b.r;
            ctx.fillStyle = hslToCss(b.color);
            fillRoundedRect(x0, y0, side, side, b.r * 0.25);
            ctx.fillStyle = "rgba(255,255,255,.22)";
            const sh = b.r * 0.5;
            fillRoundedRect(
              x0 + b.r * 0.25 - sh * 0.5,
              y0 + b.r * 0.25 - sh * 0.5,
              sh,
              sh,
              sh * 0.3
            );
          }

          // HUD refresh each frame (cheap)
          renderGeneStats();

          requestAnimationFrame(frame);
        }

        // Defaults matching previous build
        gravity = CONFIG.uiGravity.value;
        ui.gravity.value = gravity;
        restitution = CONFIG.uiBounce.value;
        ui.bounce.value = restitution;
        spawnMultiplier = CONFIG.uiSpawnPerFall.value;
        ui.mult.value = spawnMultiplier;
        ui.multNum.value = spawnMultiplier;
        holeWidthPX = CONFIG.uiHoleWidth.value;
        ui.gap.value = holeWidthPX;
        sieveHeightPX = CONFIG.uiSieveH.value;
        ui.sieveH.value = sieveHeightPX;
        speedMul = CONFIG.uiSpeedMul.value;
        ui.spd.value = speedMul;

        colorMutMul = CONFIG.uiColorMutMul.value;
        ui.colMut.value = colorMutMul;
        sizeMutMul = CONFIG.uiSizeMutMul.value;
        ui.sizeMut.value = sizeMutMul;
        startRMin = CONFIG.uiRMin.value;
        ui.rMin.value = startRMin;
        startRMax = CONFIG.uiRMax.value;
        ui.rMax.value = startRMax;
        TRAIL_LEN = CONFIG.uiTrailLen.value;
        ui.trailLen.value = TRAIL_LEN;

        autoEnabled = CONFIG.autoRestartEnabled;
        ui.autoRestart.checked = autoEnabled;
        autoThreshold = CONFIG.uiAutoThreshold.value;
        ui.autoThreshold.value = autoThreshold;

        syncUI();
        requestAnimationFrame(frame);
      })();
    </script>
  </body>
</html>
